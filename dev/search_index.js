var documenterSearchIndex = {"docs":
[{"location":"man/sublhcoptim/#Optimised-subset-of-LHC-Sampling-Plan","page":"Optimised subset of LHC Sampling Plan","title":"Optimised subset of LHC Sampling Plan","text":"","category":"section"},{"location":"man/sublhcoptim/","page":"Optimised subset of LHC Sampling Plan","title":"Optimised subset of LHC Sampling Plan","text":"Generate an optimised subset of an existing plan. The optimisation of the subset is based on a genetic algorithm.","category":"page"},{"location":"man/sublhcoptim/#Functions","page":"Optimised subset of LHC Sampling Plan","title":"Functions","text":"","category":"section"},{"location":"man/sublhcoptim/","page":"Optimised subset of LHC Sampling Plan","title":"Optimised subset of LHC Sampling Plan","text":"subLHCoptim(n::Int,d::Int,gens;popsize::Int=100,ntour::Int=2,ptour=0.8)","category":"page"},{"location":"man/sublhcoptim/#LatinHypercubeSampling.subLHCoptim-Tuple{Int64, Int64, Any}","page":"Optimised subset of LHC Sampling Plan","title":"LatinHypercubeSampling.subLHCoptim","text":"function subLHCoptim(X,n::Int,gens; rng::U=Random.GLOBAL_RNG,\n                                    popsize::Int=100,\n                                    ntour::Int=2,\n                                    ptour::Float64=0.8,\n                                    periodic_ae::Bool=false,\n                                    ae_power::Union{Int,Float64}=2) where U <: AbstractRNG\n\nProduce an optimized Latin Hyper Cube with n sample points from a subset of points in X. Optimization is run for gens generations. Returns a tuple of the sample plan and the optimization fitness history.\n\n\n\n\n\n","category":"method"},{"location":"man/sublhcoptim/","page":"Optimised subset of LHC Sampling Plan","title":"Optimised subset of LHC Sampling Plan","text":"subLHCindex(X,Xsub)","category":"page"},{"location":"man/sublhcoptim/#LatinHypercubeSampling.subLHCindex-Tuple{Any, Any}","page":"Optimised subset of LHC Sampling Plan","title":"LatinHypercubeSampling.subLHCindex","text":"function subLHCindex(X,Xsub)\n\nIndex in the large LHC to get the subLHC.\n\n\n\n\n\n","category":"method"},{"location":"man/sublhcoptim/#Example","page":"Optimised subset of LHC Sampling Plan","title":"Example","text":"","category":"section"},{"location":"man/sublhcoptim/","page":"Optimised subset of LHC Sampling Plan","title":"Optimised subset of LHC Sampling Plan","text":"Create an optimised subset LHC plan from an existing plan with 120 points in 2 dimensions.","category":"page"},{"location":"man/sublhcoptim/","page":"Optimised subset of LHC Sampling Plan","title":"Optimised subset of LHC Sampling Plan","text":"(Image: )","category":"page"},{"location":"man/sublhcoptim/","page":"Optimised subset of LHC Sampling Plan","title":"Optimised subset of LHC Sampling Plan","text":"julia> subLHCoptim(X,Xsub)","category":"page"},{"location":"man/sublhcoptim/","page":"Optimised subset of LHC Sampling Plan","title":"Optimised subset of LHC Sampling Plan","text":"(Image: )","category":"page"},{"location":"man/sublhcoptim/","page":"Optimised subset of LHC Sampling Plan","title":"Optimised subset of LHC Sampling Plan","text":"The indices of the subset in the larger plan can be extracted with","category":"page"},{"location":"man/sublhcoptim/","page":"Optimised subset of LHC Sampling Plan","title":"Optimised subset of LHC Sampling Plan","text":"julia> subLHCindex(X,Xsub)","category":"page"},{"location":"man/lhcoptim/#Optimised-Latin-Hypercube-Sampling-Plan","page":"Optimised Latin Hypercube Sampling Plan","title":"Optimised Latin Hypercube Sampling Plan","text":"","category":"section"},{"location":"man/lhcoptim/","page":"Optimised Latin Hypercube Sampling Plan","title":"Optimised Latin Hypercube Sampling Plan","text":"Create an optimised Latin Hypercube Sampling Plan using a genetic based optimisation algorithm. The objective function is the inverse of the Audze-Eglais function defined as","category":"page"},{"location":"man/lhcoptim/","page":"Optimised Latin Hypercube Sampling Plan","title":"Optimised Latin Hypercube Sampling Plan","text":"textmax  U = textmax frac1sum_p=1^P sum_q=p+1^P frac1L^2_pq","category":"page"},{"location":"man/lhcoptim/","page":"Optimised Latin Hypercube Sampling Plan","title":"Optimised Latin Hypercube Sampling Plan","text":"note: Note\nThis package maximises the inverse of the Audze-Eglais objective function.","category":"page"},{"location":"man/lhcoptim/","page":"Optimised Latin Hypercube Sampling Plan","title":"Optimised Latin Hypercube Sampling Plan","text":"where L_pq is the Euclidean norm. It is also possible to choose powers other than 2 by using the ae_power optional parameter.","category":"page"},{"location":"man/lhcoptim/","page":"Optimised Latin Hypercube Sampling Plan","title":"Optimised Latin Hypercube Sampling Plan","text":"There is also an option to use a periodic version of the Audze-Eglais which reduces clustering  along the boundaries of the sampling plan. The implementation follows the paper:","category":"page"},{"location":"man/lhcoptim/","page":"Optimised Latin Hypercube Sampling Plan","title":"Optimised Latin Hypercube Sampling Plan","text":"Jan Eliáš, Miroslav Vořechovský, Modification of the Audze–Eglājs criterion to achieve a uniform distribution of sampling points, Advances in Engineering Software, Volume 100, 2016, Pages 82-96, ISSN 0965-9978, () https://doi.org/10.1016/j.advengsoft.2016.07.004.","category":"page"},{"location":"man/lhcoptim/#Function","page":"Optimised Latin Hypercube Sampling Plan","title":"Function","text":"","category":"section"},{"location":"man/lhcoptim/","page":"Optimised Latin Hypercube Sampling Plan","title":"Optimised Latin Hypercube Sampling Plan","text":"LHCoptim(n::Int,d::Int,gens;    rng::U=Random.GLOBAL_RNG,\n                                popsize::Int=100,\n                                ntour::Int=2,\n                                ptour=0.8,\n                                dims::Array{T,1}=[Continuous() for i in 1:d],\n                                interSampleWeight::Float64=1.0,\n                                periodic_ae::Bool=false,\n                                ae_power::Union{Int,Float64}=2,\n                                threading=false) where T <: LHCDimension where U <: AbstractRNG","category":"page"},{"location":"man/lhcoptim/#LatinHypercubeSampling.LHCoptim-Union{Tuple{T}, Tuple{U}, Tuple{Int64, Int64, Any}} where {U<:AbstractRNG, T<:LHCDimension}","page":"Optimised Latin Hypercube Sampling Plan","title":"LatinHypercubeSampling.LHCoptim","text":"function LHCoptim(n::Int,d::Int,gens;   rng::U=Random.GLOBAL_RNG,\n                                        popsize::Int=100,\n                                        ntour::Int=2,\n                                        ptour=0.8,\n                                        dims::Array{T,1}=[Continuous() for i in 1:d],\n                                        interSampleWeight::Float64=1.0,\n                                        periodic_ae::Bool=false,\n                                        ae_power::Union{Int,Float64}=2) where T <: LHCDimension where U <: AbstractRNG\n\nProduce an optimized Latin Hyper Cube with d dimensions and n sample points. Optimization is run for gens generations. Returns a tuple of the sample plan and  the optimization fitness history.\n\n\n\n\n\n","category":"method"},{"location":"man/lhcoptim/","page":"Optimised Latin Hypercube Sampling Plan","title":"Optimised Latin Hypercube Sampling Plan","text":"Where gens is the number of generations to run the optimisation for. The population size, number of samples selected for tournament, as well as the probability for tournament selection in the genetic algorithm, can be accessed with the optional arguments popsize=100, ntour=2 and ptour=0.8. These are manually tuned defaults and may not be optimal depending on the number of dimensions and the size of the plan.","category":"page"},{"location":"man/lhcoptim/","page":"Optimised Latin Hypercube Sampling Plan","title":"Optimised Latin Hypercube Sampling Plan","text":"The RNG can be specified or else the global RNG will be used. ","category":"page"},{"location":"man/lhcoptim/","page":"Optimised Latin Hypercube Sampling Plan","title":"Optimised Latin Hypercube Sampling Plan","text":"Multithreading can be used by starting Julia with multiple threads and specifying threading=true.","category":"page"},{"location":"man/lhcoptim/","page":"Optimised Latin Hypercube Sampling Plan","title":"Optimised Latin Hypercube Sampling Plan","text":"note: Note\nSpecifying a rng does not yield the same result each time when running the plan threaded. ","category":"page"},{"location":"man/lhcoptim/","page":"Optimised Latin Hypercube Sampling Plan","title":"Optimised Latin Hypercube Sampling Plan","text":"The optimisation of a sampling plan is started from a random plan which is also an exported function.","category":"page"},{"location":"man/lhcoptim/","page":"Optimised Latin Hypercube Sampling Plan","title":"Optimised Latin Hypercube Sampling Plan","text":"randomLHC(n::Int, d::Int)","category":"page"},{"location":"man/lhcoptim/#LatinHypercubeSampling.randomLHC-Tuple{Int64, Int64}","page":"Optimised Latin Hypercube Sampling Plan","title":"LatinHypercubeSampling.randomLHC","text":"function randomLHC(n::Int, d::Int)\n\nGenerate a random Latin Hypercube with d dimensions and n sample points.\n\n\n\n\n\n","category":"method"},{"location":"man/lhcoptim/#Example","page":"Optimised Latin Hypercube Sampling Plan","title":"Example","text":"","category":"section"},{"location":"man/lhcoptim/","page":"Optimised Latin Hypercube Sampling Plan","title":"Optimised Latin Hypercube Sampling Plan","text":"The LHCoptim function run for many generations to create an optimised 120 point plan in 2 dimensions. Both the plan and the fitness of the sampling plan are exported.","category":"page"},{"location":"man/lhcoptim/","page":"Optimised Latin Hypercube Sampling Plan","title":"Optimised Latin Hypercube Sampling Plan","text":"julia> plan, fitness = LHCoptim(120,2,gens)","category":"page"},{"location":"man/lhcoptim/","page":"Optimised Latin Hypercube Sampling Plan","title":"Optimised Latin Hypercube Sampling Plan","text":"(Image: )","category":"page"},{"location":"man/lhcoptim/","page":"Optimised Latin Hypercube Sampling Plan","title":"Optimised Latin Hypercube Sampling Plan","text":"If only the plan is required, the fitness can be omitted using ","category":"page"},{"location":"man/lhcoptim/","page":"Optimised Latin Hypercube Sampling Plan","title":"Optimised Latin Hypercube Sampling Plan","text":"julia> plan, _ = LHCoptim(120,2,gens)","category":"page"},{"location":"man/lhcoptim/","page":"Optimised Latin Hypercube Sampling Plan","title":"Optimised Latin Hypercube Sampling Plan","text":"The results can be scaled to a suitable range with the exported function scaleLHC.","category":"page"},{"location":"man/lhcoptim/","page":"Optimised Latin Hypercube Sampling Plan","title":"Optimised Latin Hypercube Sampling Plan","text":"julia> plan, _ = LHCoptim(100,2,1000)\njulia> scaled_plan = scaleLHC(plan,[(-5.0,5.0),(-5.0,5.0)])","category":"page"},{"location":"man/lhcoptim/","page":"Optimised Latin Hypercube Sampling Plan","title":"Optimised Latin Hypercube Sampling Plan","text":"which can then be used to sample a function as ","category":"page"},{"location":"man/lhcoptim/","page":"Optimised Latin Hypercube Sampling Plan","title":"Optimised Latin Hypercube Sampling Plan","text":"julia> rosenbrock_2D(x) = (1.0 - x[1])^2 + 100.0 * (x[2] - x[1]^2)^2\njulia> mapslices(rosenbrock_2D,scaled_plan; dims=2)","category":"page"},{"location":"man/categorical/#Categorical-Latin-Hypercube-Sampling-Plan","page":"Categorical Latin Hypercube Sampling Plan","title":"Categorical Latin Hypercube Sampling Plan","text":"","category":"section"},{"location":"man/categorical/","page":"Categorical Latin Hypercube Sampling Plan","title":"Categorical Latin Hypercube Sampling Plan","text":"Categorical Latin Hypercube plans allows one to mix discrete and continuous data  in the same plan. ","category":"page"},{"location":"man/categorical/#Example","page":"Categorical Latin Hypercube Sampling Plan","title":"Example","text":"","category":"section"},{"location":"man/categorical/","page":"Categorical Latin Hypercube Sampling Plan","title":"Categorical Latin Hypercube Sampling Plan","text":"Say we have two continuous dimensions as well as one on/off, discrete, dimension.  These can be included in the same sampling plan with","category":"page"},{"location":"man/categorical/","page":"Categorical Latin Hypercube Sampling Plan","title":"Categorical Latin Hypercube Sampling Plan","text":"julia> numPoints = 100\njulia> catWeight = 0.01\njulia> dims = [Continuous(),Continuous(),Categorical(2,catWeight)]\njulia> initialSample = randomLHC(numPoints,dims)\njulia> X = LHCoptim!(initialSample,gens;dims=dims)[1]","category":"page"},{"location":"man/categorical/","page":"Categorical Latin Hypercube Sampling Plan","title":"Categorical Latin Hypercube Sampling Plan","text":"note: Note\nThis is no longer strictly a Latin Hypercube because of the introduction of  categorical values.","category":"page"},{"location":"man/categorical/","page":"Categorical Latin Hypercube Sampling Plan","title":"Categorical Latin Hypercube Sampling Plan","text":"The Audze-Eglais objective function is altered to include the separation within  each plane of the categorical values in addition to the separation between all points. It's possible to weight each objective separately so the user can achieve their desired sampling plan. The objective function is calculated as the sum of the Audze-Eglais function between all points and the Audze-Eglais function within each category. ","category":"page"},{"location":"man/categorical/","page":"Categorical Latin Hypercube Sampling Plan","title":"Categorical Latin Hypercube Sampling Plan","text":"The weights for each categorical plane can be supplied by the user through the Categorical type Categorical(numCategories,catWeight). Similarly the weight controlling the separation between all points can be accessed by the user through the optional argument  interSampleWeight which is set to 1 by default.","category":"page"},{"location":"man/categorical/","page":"Categorical Latin Hypercube Sampling Plan","title":"Categorical Latin Hypercube Sampling Plan","text":"Large emphasis can be put on keeping the separation within each plane by increasing its weight. This is similar to doing a separate LHC for each categorical  dimension. ","category":"page"},{"location":"man/categorical/","page":"Categorical Latin Hypercube Sampling Plan","title":"Categorical Latin Hypercube Sampling Plan","text":"julia> catWeight = 1000.0\njulia> dims = [Continuous(),Continuous(),Categorical(2,catWeight)]\njulia> julia> X = LHCoptim!(initialSample,gens;dims=dims)[1]","category":"page"},{"location":"man/categorical/","page":"Categorical Latin Hypercube Sampling Plan","title":"Categorical Latin Hypercube Sampling Plan","text":"using PlotlyJS, LatinHypercubeSampling # hide\nnumPoints = 100 # hide\ncatWeight = 1000.0 # hide\ndims = [Continuous(),Continuous(),Categorical(2,catWeight)]  # hide\ninitialSample = randomLHC(numPoints,dims) # hide \nX = LHCoptim!(initialSample,50;dims=dims)[1] # hide \n\nfunction plotlhc(X,titletext) # hide\n    x1 = X[X[:,3].==1,:] # hide\n    x2 = X[X[:,3].==2,:] # hide\n    trace1 = scatter(;x=x1[:,1], y=x1[:,2], # hide\n                        mode=\"markers\", name=\"Category 1\", # hide\n                        marker_size=12) # hide\n\n    trace2 = scatter(;x=x2[:,1], y=x2[:,2], # hide\n                        mode=\"markers\", name=\"Category 2\", # hide\n                        marker_size=12) # hide\n\n    \n    data = [trace1, trace2] # hide\n    layout = Layout(height=650, # hide\n                    width=740, # hide\n                    title=titletext, # hide\n                    xaxis=attr(title=\"Continuous dim. 1\"), # hide\n                    yaxis=attr(title=\"Continuous dim. 2\"), # hide\n                    margin=attr(l=100, r=30, b=50, t=90), # hide\n                                ) # hide\n    plot(data, layout) # hide\nend # hide\n\np = plotlhc(X,\"Promote in-plane separation\") # hide\npkgpath = abspath(joinpath(dirname(Base.find_package(\"LatinHypercubeSampling\")), \"..\")) # hide\nsavedir = joinpath(pkgpath,\"docs\",\"src\",\"assets\",\"example1.html\") # hide\nPlotlyJS.savefig(p,savedir) # hide","category":"page"},{"location":"man/categorical/","page":"Categorical Latin Hypercube Sampling Plan","title":"Categorical Latin Hypercube Sampling Plan","text":"    <iframe src=\"../../assets/example1.html\" style=\"width: 100%; height: 765px; border: none\" seamless=\"seamless\" scrolling=\"no\"></iframe>","category":"page"},{"location":"man/categorical/","page":"Categorical Latin Hypercube Sampling Plan","title":"Categorical Latin Hypercube Sampling Plan","text":"Similarly we can turn of the separation within planes entirely with ","category":"page"},{"location":"man/categorical/","page":"Categorical Latin Hypercube Sampling Plan","title":"Categorical Latin Hypercube Sampling Plan","text":"julia> catWeight = 0.0\njulia> dims = [Continuous(),Continuous(),Categorical(2,catWeight)]\njulia> X = LHCoptim!(initialSample,gens;dims=dims)[1]","category":"page"},{"location":"man/categorical/","page":"Categorical Latin Hypercube Sampling Plan","title":"Categorical Latin Hypercube Sampling Plan","text":"catWeight = 0.0 # hide\ndims = [Continuous(),Continuous(),Categorical(2,catWeight)] # hide\nX = LHCoptim!(initialSample,50;dims=dims)[1] # hide \n\n\np = plotlhc(X,\"Promote inter sample separation\") # hide\npkgpath = abspath(joinpath(dirname(Base.find_package(\"LatinHypercubeSampling\")), \"..\")) # hide\nsavedir = joinpath(pkgpath,\"docs\",\"src\",\"assets\",\"example2.html\") # hide\nPlotlyJS.savefig(p,savedir) # hide","category":"page"},{"location":"man/categorical/","page":"Categorical Latin Hypercube Sampling Plan","title":"Categorical Latin Hypercube Sampling Plan","text":"    <iframe src=\"../../assets/example2.html\" style=\"width: 100%; height: 765px; border: none\" seamless=\"seamless\" scrolling=\"no\"></iframe>","category":"page"},{"location":"#LatinHypercubeSampling","page":"Home","title":"LatinHypercubeSampling","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LatinHypercubeSampling is a Julia package for the creation of optimised Latin Hypercube (LHC) Sampling Plans. The genetic optimisation algorithm is largely based on the work by Bates et al. [1]. The package includes additional functionality for the creation of an optimised subset of an existing plan, as well  as the inclusion of discrete parameters.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is registered and can be installed with Pkg.add.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> Pkg.add(\"LatinHypercubeSampling\")","category":"page"},{"location":"#Reference","page":"Home","title":"Reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]: Stuart Bates, Johann Sienz, and Vassili Toropov. \"Formulation of the Optimal Latin Hypercube Design of Experiments Using a Permutation Genetic Algorithm\", 45th AIAA/ASME/ASCE/AHS/ASC Structures, Structural Dynamics & Materials Conference, Structures, Structural Dynamics, and Materials and Co-located Conferences, () https://doi.org/10.2514/6.2004-2011","category":"page"}]
}
