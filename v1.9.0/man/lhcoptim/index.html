<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Optimised Latin Hypercube Sampling Plan · LatinHypercubeSampling.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="LatinHypercubeSampling.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">LatinHypercubeSampling.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li class="is-active"><a class="tocitem" href>Optimised Latin Hypercube Sampling Plan</a><ul class="internal"><li><a class="tocitem" href="#Function"><span>Function</span></a></li><li><a class="tocitem" href="#Example"><span>Example</span></a></li></ul></li><li><a class="tocitem" href="../sublhcoptim/">Optimised subset of LHC Sampling Plan</a></li><li><a class="tocitem" href="../categorical/">Categorical Latin Hypercube Sampling Plan</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Optimised Latin Hypercube Sampling Plan</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Optimised Latin Hypercube Sampling Plan</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/MrUrq/LatinHypercubeSampling.jl/blob/master/docs/src/man/lhcoptim.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Optimised-Latin-Hypercube-Sampling-Plan"><a class="docs-heading-anchor" href="#Optimised-Latin-Hypercube-Sampling-Plan">Optimised Latin Hypercube Sampling Plan</a><a id="Optimised-Latin-Hypercube-Sampling-Plan-1"></a><a class="docs-heading-anchor-permalink" href="#Optimised-Latin-Hypercube-Sampling-Plan" title="Permalink"></a></h1><p>Create an optimised Latin Hypercube Sampling Plan using a genetic based optimisation algorithm. The objective function is the inverse of the Audze-Eglais function defined as</p><p class="math-container">\[\text{max } U = \text{max} \frac{1}{\sum_{p=1}^P \sum_{q=p+1}^P \frac{1}{L^2_{pq}}}\]</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This package maximises the inverse of the Audze-Eglais objective function.</p></div></div><p>where <span>$L_{pq}$</span> is the Euclidean norm. It is also possible to choose powers other than 2 by using the <code>ae_power</code> optional parameter.</p><p>There is also an option to use a periodic version of the Audze-Eglais which reduces clustering  along the boundaries of the sampling plan. The implementation follows the paper:</p><p>Jan Eliáš, Miroslav Vořechovský, Modification of the Audze–Eglājs criterion to achieve a uniform distribution of sampling points, Advances in Engineering Software, Volume 100, 2016, Pages 82-96, ISSN 0965-9978, () https://doi.org/10.1016/j.advengsoft.2016.07.004.</p><h2 id="Function"><a class="docs-heading-anchor" href="#Function">Function</a><a id="Function-1"></a><a class="docs-heading-anchor-permalink" href="#Function" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LatinHypercubeSampling.LHCoptim-Union{Tuple{T}, Tuple{U}, Tuple{Int64, Int64, Any}} where {U&lt;:AbstractRNG, T&lt;:LHCDimension}" href="#LatinHypercubeSampling.LHCoptim-Union{Tuple{T}, Tuple{U}, Tuple{Int64, Int64, Any}} where {U&lt;:AbstractRNG, T&lt;:LHCDimension}"><code>LatinHypercubeSampling.LHCoptim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function LHCoptim(n::Int,d::Int,gens;   rng::U=Random.GLOBAL_RNG,
                                        popsize::Int=100,
                                        ntour::Int=2,
                                        ptour=0.8,
                                        dims::Array{T,1}=[Continuous() for i in 1:d],
                                        interSampleWeight::Float64=1.0,
                                        periodic_ae::Bool=false,
                                        ae_power::Union{Int,Float64}=2) where T &lt;: LHCDimension where U &lt;: AbstractRNG</code></pre><p>Produce an optimized Latin Hyper Cube with <code>d</code> dimensions and <code>n</code> sample points. Optimization is run for <code>gens</code> generations. Returns a tuple of the sample plan and  the optimization fitness history.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MrUrq/LatinHypercubeSampling.jl/blob/08f4b99d67a3b6099bf45968651a6f0c818616a2/src/LatinHypercubeSampling.jl#L130-L142">source</a></section></article><p>Where <code>gens</code> is the number of generations to run the optimisation for. The population size, number of samples selected for tournament, as well as the probability for tournament selection in the genetic algorithm, can be accessed with the optional arguments <code>popsize=100</code>, <code>ntour=2</code> and <code>ptour=0.8</code>. These are manually tuned defaults and may not be optimal depending on the number of dimensions and the size of the plan.</p><p>The RNG can be specified or else the global RNG will be used. </p><p>Multithreading can be used by starting Julia with multiple threads and specifying <code>threading=true</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Specifying a rng does not yield the same result each time when running the plan threaded. </p></div></div><p>The optimisation of a sampling plan is started from a random plan which is also an exported function.</p><article class="docstring"><header><a class="docstring-binding" id="LatinHypercubeSampling.randomLHC-Tuple{Int64, Int64}" href="#LatinHypercubeSampling.randomLHC-Tuple{Int64, Int64}"><code>LatinHypercubeSampling.randomLHC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function randomLHC(n::Int, d::Int)</code></pre><p>Generate a random Latin Hypercube with <code>d</code> dimensions and <code>n</code> sample points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MrUrq/LatinHypercubeSampling.jl/blob/08f4b99d67a3b6099bf45968651a6f0c818616a2/src/LatinHypercubeSampling.jl#L99-L102">source</a></section></article><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><p>The <code>LHCoptim</code> function run for many generations to create an optimised 120 point plan in 2 dimensions. Both the plan and the fitness of the sampling plan are exported.</p><pre><code class="language-julia-repl hljs">julia&gt; plan, fitness = LHCoptim(120,2,gens)</code></pre><p><img src="https://raw.githubusercontent.com/MrUrq/LatinHypercubeSampling.jl/master/docs/src/assets/120p2d.png" alt/></p><p>If only the plan is required, the fitness can be omitted using </p><pre><code class="language-julia-repl hljs">julia&gt; plan, _ = LHCoptim(120,2,gens)</code></pre><p>The results can be scaled to a suitable range with the exported function <code>scaleLHC</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; plan, _ = LHCoptim(100,2,1000)
julia&gt; scaled_plan = scaleLHC(plan,[(-5.0,5.0),(-5.0,5.0)])</code></pre><p>which can then be used to sample a function as </p><pre><code class="language-julia-repl hljs">julia&gt; rosenbrock_2D(x) = (1.0 - x[1])^2 + 100.0 * (x[2] - x[1]^2)^2
julia&gt; mapslices(rosenbrock_2D,scaled_plan; dims=2)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../sublhcoptim/">Optimised subset of LHC Sampling Plan »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 16 May 2023 22:26">Tuesday 16 May 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
